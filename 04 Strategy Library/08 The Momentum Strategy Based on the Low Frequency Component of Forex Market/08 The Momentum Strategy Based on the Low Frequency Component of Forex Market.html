<h2>Abstract</h2>
Trend estimation is a family of methods to detect and predict tendencies and trends in price series just using the history information. Moving average is a commonly used trend following trading tool. Lots of momentum trading strategies in the Forex market are based on the moving average rule, in which signals are triggered if the close is above or below the moving average. But MA has the time lag, therefore can't be used to predict the turning points of market price changes.

In this tutorial, I developed a trend following strategy which is proposed in the paper Harris R D F, Yilmaz F(2009) [ref]Harris R D F, Yilmaz F. A momentum trading strategy based on the low-frequency component of the exchange rate[J]. Journal of Banking &amp; Finance, 2009, 33(9): 1575-1585. <a href="http://www.sciencedirect.com/science/article/pii/S0378426609000521">online copy</a>[/ref].

This strategy exploits short-term momentum in the non-linear trend component of the exchange rate which is generated by Hodrick-Prescott Filter (rather than the exchange rate itself) and uses the MA(1, 2) rule to measure this momentum. The strategy was tested on seven kinds of exchange rates and the results shows less robustness and the performance is sensitive to the change of model parameters.

<h2>Introduction</h2>
Hodrick-Prescott Filter decomposes a time series\(y_t\) into two components: the cyclical part(which is short-term) and the trend part(which is long term).

\[y_t=\x _t +c_t\]

The filter is the solution to the following optimization problem for \(x_t\)

\[\min _{x_t}\left[\sum_{t=1}^n(y_t-x_t)^2+\lambda\sum_{t=2}^{n-1}[(x_{t+1}-x_t)-(x_{t}-x_{t-1})^2] \right]\]

[ref]Dao T L. Momentum Strategies with L1 Filter[J]. Browser Download This Paper, 2014. <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2780280">online copy</a>[/ref]The second term is the discrete derivative of the trend xt which characterizes the smoothness of the curve. We can rewrite the above formula in vector form:

\[\min_{\bf x}{\parallel {\bf{y}}-{\bf{x}}\parallel}_2^2+\lambda {\parallel D\bf x\parallel}_2^2\]

where \({\bf y}=(y_1,y_2,...,y_n),{\bf x}=(x_1,x_2,...,x_n)\in {\rm I\!R}^n\),\(\parallel\cdot\parallel_2\) is the Euclidean norm. D is the (n-2)*n matrix:

\[

\left[
\begin{matrix}
1 &amp; -2 &amp; 1 &amp; \\
&amp; 1 &amp; -2 &amp; 1 \\
&amp; &amp; &amp; \ddots &amp;\\
&amp; &amp; &amp; 1 &amp; -2 &amp; 1 \\
&amp; &amp; &amp; &amp; 1 &amp; -2 &amp; 1 \\
\end{matrix}
\right]

\]

The solution of this optimization problem is given by solving the following linear system:

\[y=(I+2\lambda D^TD)^{-1}x\]
<pre class="prettyprint linenums">def hpfilter(self,X, lamb=1600):
    X = np.asarray(X, float)
    if X.ndim &gt; 1:
    X = X.squeeze()
    nobs = len(X)
    I = sparse.eye(nobs,nobs)
    offsets = np.array([0,1,2])
    data = np.repeat([[1.],[-2.],[1.]], nobs, axis=1)
    K = sparse.dia_matrix((data, offsets), shape=(nobs-2,nobs))
    use_umfpack = True
    self.trend = spsolve(I+lamb*K.T.dot(K), X,use_umfpack=use_umfpack)
    cycle = X - self.trend
</pre>

<h2>Method</h2>

This low-frequency momentum trading strategies are applied to daily data on seven kinds of exchange rates. We use five years history data before January 2011 for initial estimation of the trend model. Daily exchange rates for the period January 2011 to May 2017 is used for out of sample trading.
<pre class="prettyprint linenums">def Initialize(self):
    self.SetStartDate(2011,1,1)
    self.SetEndDate(2017,5,30)
    self.SetCash(100000)
    self.numdays = 360*5  # set the length of training period
    self.syl = self.AddSecurity(SecurityType.Forex, "EURUSD", Resolution.Daily).Symbol
    self.n,self.m = 2, 1
    self.trend = None
    self.SetBenchmark(self.syl)
    self.MA_rules = None
    history = self.History(self.numdays,Resolution.Daily)
    self.close = [slice[self.syl].Close for slice in history]</pre>

<h3>Step 1: Calibrating the Filter Smoothing Parameter λ</h3>
The Ravn–Uhlig rule is commonly used to set the smoothing parameter λ in HP filter and must be greater than 0. It is adjusted by the changing frequency of observations and must be greater than 0. Hodrick and Prescott (1997) recommended setting λ to 1,600 for quarterly data. The Ravn–Uhlig rule sets  \(\lambda = 1600p^4\) , where p is the number of periods per quarter. As for our daily exchange rate data, we should have set λ to be \(\1600\times (30 \times 4)^4\). But when we use this value as the λ, the curve is almost a straight line since the trend becomes smoother as λ → ∞. In order to avoid excessive smoothing, we gradually decrease the λ and draw the smoothing curve. Below is the chart of EURUSD daily price from the year 2010 to 2011. t100 denotes the trend component after filter with the parameter λ=100.

<img src="https://cdn.quantconnect.com/tutorials/i/Tutorial08-low-frequency-component-more.jpg" alt="low-frequency-component-more” />

If we just plot the curve for the first 100 days, we find that the smaller the λ, the more apparent the trend. The curve does not change too much as the λ  smaller than 100. Thus here we choose  λ=100 to extract the trend of daily price data. This trend is our low-frequency component.
<img src="https://cdn.quantconnect.com/tutorials/i/Tutorial08-low-frequency-component-less.jpg" alt="low-frequency-component-less”/>

<p style="text-align: center;">Out-of-sample EUR/USD Trend Estimation</p>

<img src="https://cdn.quantconnect.com/tutorials/i/Tutorial08-out-of-sample-trend-estimation.jpg" alt="out-of-sample-trend-estimation” />
<h3>Step 2: Setting up the Moving Average Rule</h3>

Moving average (MA) rules are very commonly used to generate buy and sell signals from data on the spot exchange rate. The MA rule compares a short-run moving average of the current and lagged exchange rate with a long-run moving average.

\[MA(m,n)=\frac{1}{m}\sum_{i=0}^{m-1}S_{t-i}-\frac{1}{n}\sum_{i=0}^{n-1}S_{t-i}\]


For HP filter, the non-linear trend is estimated recursively as the paper did. The initial estimation was undertaken using 3 years history data before 2011. The estimation period is then rolled forward each day through the trading period from January 2011 to May 2017.

<h3>Step 3: Generating the Trading Signals</h3>
We generate buy and sell signals by applying an MA(1, 2) rule to the estimated low-frequency component. For MA(m,n), m must be 1 which denotes the current value of low-frequency component. n should be small since large n would generate large time lag, the judgment of turning points is not accurate.

A buy signal is generated when the current day’s low-frequency trend is higher than the last day’s low-frequency trend and a sell signal is generated when it is lower.
<pre class="prettyprint linenums">
def OnData(self,data):
    self.close.append(self.Portfolio[self.syl].Price)
    self.hpfilter(self.close[-self.numdays:len(self.close)+1], 100)
    self.MA_rules_today = (np.mean(self.trend[-self.m : len(self.trend)]) - np.mean(self.trend[-self.n : len(self.trend)]))
    self.MA_rules_yesterday = (np.mean(self.trend[-self.m-1: len(self.trend)-1]) - np.mean(self.trend[-self.n-1 : len(self.trend)-1]))
    holdings = self.Portfolio[self.syl].Quantity

    if self.MA_rules_today &gt; 0 and self.MA_rules_yesterday &lt; 0:
       self.SetHoldings(self.syl, 1)
    elif self.MA_rules_today &lt; 0 and self.MA_rules_yesterday &gt; 0:
       self.SetHoldings(self.syl, -1)
</pre>
<p style="text-align: center;">Trading Signals when λ=1600</p>

<img src="https://cdn.quantconnect.com/tutorials/i/Tutorial08-trading-signal-1600.jpg" alt="trading-signal 1600.jpg” />

<p style="text-align: center;">Trading Signals when λ=100</p>
<img src="https://cdn.quantconnect.com/tutorials/i/Tutorial08-trading-signal-100.jpg" alt="trading-signal-100.jpg" />

The above charts are the in-sample trading signals after applying MA rules on the low-frequency component. The trend curve is more smooth with larger λ. Thus when we applied MA rules, a less smooth trend will trigger more trading opportunities.
<h2>Conclusion</h2>
<table class="table qc-table">
<thead>
<tr>
<th style="text-align: center;" colspan="8">Strategy Performance for different currencies in Forex</th>
</tr>
</thead>
<tbody>
<tr>
<td>Currency</td>
<td>USDCAD</td>
<td>EURUSD</td>
<td> USDCHF</td>
<td> EURGBP</td>
<td>CADUSD</td>
<td>USDNOK</td>
<td>USDZAR</td>
</tr>
<tr>
<td>Sharp Ratio</td>
<td>0.361</td>
<td>0.375</td>
<td> 0.131</td>
<td> 0.337</td>
<td> 0.052</td>
<td> 0.054</td>
<td> 0.195</td>
</tr>
<tr>
<td> Total Trades</td>
<td> 14</td>
<td> 11</td>
<td> 12</td>
<td> 11</td>
<td> 6</td>
<td> 16</td>
<td> 9</td>
</tr>
<tr>
<td> Annual Return</td>
<td> 3.128%</td>
<td> 3.272%</td>
<td> 1.162%</td>
<td> 2.689%</td>
<td> 0.043%</td>
<td> 0.093%</td>
<td> 2.201%</td>
</tr>
<tr>
<td> Max Drawdown</td>
<td> 10.3%</td>
<td> 8.3%</td>
<td> 24.8%</td>
<td> 17.6%</td>
<td> 22.5%</td>
<td> 30.3%</td>
<td> 23%</td>
</tr>
</tbody>
</table>

The table reports the strategy performance statistics during six and a half years backtesting period. From the table we can see, most of them have the higher maximum drawdown. The number of total trades is small because we applied MA rules on the smoothed trend component.  As the author indicated in the paper, we still find that the performance of this strategy is very sensitive to the choice of lag parameters in MA rules and in a non-monotonic way.

The strategy does not generate more stable profits in Forex market generally. That might because that the HP filter technique was designed to be viewed as a trend curve through the entire set of data. When we applied it in trading strategy, the entry of new data into the filter model can cause the trend line to change the trend through past data, makes it harder to identify the trend accurately.

We also tried the kernel regression method in the paper. However, because the distribution parameter in the Python kernel regression package can not be adjusted. The appropriate trend component is not being extracted well from kernel regression. The smoothing effect of the regression is not good as expected. Thus here we choose not to move on to the trading part of kernel regression method.
<h2>Algorithm</h2>
<script src='https://www.quantconnect.com/terminal/backtest.js?sid=5188517de3244425b56af3e717c90cb9'></script>
